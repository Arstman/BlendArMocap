:py:mod:`BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers`
=======================================================

.. py:module:: BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.Variable
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.SingleProperty
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.TransformChannel
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.RotationalDifference
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.Distance
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.DriverFactory




Attributes
~~~~~~~~~~

.. autoapisummary::

   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.transform_modes
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.rotation_modes
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.DriverVariable
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.DriverExpression
   BlendArMocap.src.cgt_core.cgt_bpy.cgt_drivers.cube


.. py:data:: transform_modes

   

.. py:data:: rotation_modes

   

.. py:class:: Variable

   .. py:attribute:: name
      :type: str

      

   .. py:attribute:: type
      :type: str

      

   .. py:attribute:: obj
      :type: Any

      

   .. py:method:: assign()
      :abstractmethod:


   .. py:method:: _set_variable(driver_variable: bpy.types.DriverVariable = None)


   .. py:method:: _set_variable_target(variable_target, obj)


   .. py:method:: _validate(driver_variable)



.. py:class:: SingleProperty(name: str, obj: Any, path: str)

   Bases: :py:obj:`Variable`

   .. py:attribute:: path
      :type: str

      

   .. py:method:: assign(driver_variable: bpy.types.DriverVariable = None)



.. py:class:: TransformChannel(name: str, obj: bpy.types.Object, transform: str, idx: int, transform_space: str = 'WORLD_SPACE')

   Bases: :py:obj:`Variable`

   .. py:attribute:: transform_type

      

   .. py:attribute:: transform_space

      

   .. py:method:: _validated_transform_space(transform, transform_space)


   .. py:method:: get_transform_type(transform, idx)


   .. py:method:: assign(driver_variable: bpy.types.DriverVariable = None)



.. py:class:: RotationalDifference(name: str, obj: bpy.types.Object, other_obj: bpy.types.Object)

   Bases: :py:obj:`Variable`

   .. py:attribute:: other_object
      :type: bpy.types.Object

      

   .. py:method:: assign(driver_variable: bpy.types.DriverVariable = None)



.. py:class:: Distance(name: str, obj: bpy.types.Object, other_obj: bpy.types.Object, transform_space: str = 'WORLD_SPACE', other_transform_space: str = 'WORLD_SPACE')

   Bases: :py:obj:`Variable`

   .. py:attribute:: other_obj
      :type: bpy.types.Object

      

   .. py:attribute:: transform_space
      :type: str

      

   .. py:attribute:: other_transform_space
      :type: str

      

   .. py:method:: assign(driver_variable: bpy.types.DriverVariable = None)



.. py:data:: DriverVariable

   

.. py:data:: DriverExpression

   

.. py:class:: DriverFactory(target: Any, type: str = 'SCRIPTED')

   .. py:attribute:: expressions
      :type: dict

      

   .. py:method:: add_variable(variable: Variable, path: str, idx: int)

      Adds driver variable. 


   .. py:method:: add_expression(expression: str, path: str, idx: int = None)

      Adds a driver expression. 


   .. py:method:: expand_expression(expression: str, path: str, idx: int = None)

      Previous expression gets encapsulated and wrapped in a new expression.
      Make sure to use brackets to place the previous expression {}.


   .. py:method:: _add_driver_variable(path: str, idx: int, driver_variable: Any)

      Adds a driver variable to the driver variables dict. 


   .. py:method:: _in_driver_variables(path: str, idx: int)

      Checks if path and idx are in the driver variables dict. 


   .. py:method:: driver_add_variable(path, idx)


   .. py:method:: execute()

      Adds driver variables to object and stores them. 



.. py:data:: cube

   

